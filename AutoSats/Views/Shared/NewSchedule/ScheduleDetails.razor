@inject IExchangeServiceFactory factory
@inject IExchangeScheduler scheduler
@inject MessageService message
@inject IWalletService wallet 

<div>
    <Form Model="details" LabelColSpan="12" WrapperColSpan="12" OnFinish="SaveScheduleAsync" Loading="isSaving">
        <Row Gutter="12">
            <GridCol Span="24">
                <Paragraph Class="schedule-description">
                    Define <strong>how much</strong> you want to spend and <strong>how often</strong>. It is also highly recommended not to leave your bitcoin on the exchange
                    but <strong>withdraw</strong> it to your own wallet.
                    <Tooltip Title="@("Remember - not your keys, not your coins!")">
                        <Icon Type="info-circle" />
                    </Tooltip>
                    <br />
                    If you setup automatic withdrawal, set the minimum withdrawal limit (most exchanges have withdrawal fees, so it might not makes sense to withdraw after each buy)
                    and which <strong>address</strong> you want to withdraw to. You can either set a <strong>fixed</strong> address
                    or have a <strong>new one generated</strong> for each withdrawal.
                    <Tooltip Title="@("The address gets generated by your wallet.")">
                        <Icon Type="info-circle" />
                    </Tooltip>
                </Paragraph>
            </GridCol>
        </Row>
        <Row Gutter="12">
            <GridCol Span="12">
                <FormItem Label="How much to spend" Required>
                    <Tooltip Title="@("AutoSats will first fetch the current price and then place an order to spend the given amount. Because a market order will be placed, the amount actually spent might slightly differ compared to the entered value.")">
                        <NumberInput @bind-Value="context.Spend"
                                         Class="element-stretch"
                                         Type="number"
                                         step="any">
                            <AddOnAfter>
                                <Select DataSource="KeysWithBalances?.Balances"
                                        @bind-Value="context.Symbol"
                                        TItem="SymbolBalance"
                                        TItemValue="Symbol"
                                        ValueName="@nameof(Symbol)"
                                        Placeholder="Currency"
                                        Class="currencies-select">
                                    <LabelTemplate Context="ctx">
                                        <span class="balance-label">@ctx.Symbol.Spend</span>
                                    </LabelTemplate>
                                    <ItemTemplate Context="ctx">
                                        <div class="balance-item">
                                            <span class="currency">@ctx.Symbol.Spend</span>
                                            <span class="amount">@(ctx.Amount < 100 ? ctx.Amount.ToString("N2") : ctx.Amount.ToString("N0"))</span>
                                        </div>
                                    </ItemTemplate>
                                </Select>
                            </AddOnAfter>
                        </NumberInput>
                    </Tooltip>
                </FormItem>

                <FormItem Label="How often" Required="true">
                    <EnumSelect TEnum="SchedulePeriod"
                                @bind-Value="selectedPeriod"
                                OnSelectedItemChanged="@(x => UpdateCronExpression(x, context.Start))" />
                </FormItem>

                @if (selectedPeriod == SchedulePeriod.Cron)
                {
                    <FormItem Label="Cron expression">
                        <AntDesign.Input @bind-Value="context.Cron">
                            <Suffix>
                                <Popover Title="Custom cron expression">
                                    <ContentTemplate>
                                        The cron format needs to follow <a target="_blank" href="https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html#example-cron-expressions">Quartz.net</a>'s specification.
                                        <br />
                                        You can use this <a target="_blank" href="https://www.freeformatter.com/cron-expression-generator-quartz.html">generator</a> to create the expression.
                                    </ContentTemplate>
                                    <ChildContent>
                                        <Icon Type="info-circle" />
                                    </ChildContent>
                                </Popover>
                            </Suffix>
                        </AntDesign.Input>
                    </FormItem>

                    <FormItem Label="Start date" Required>
                        <DatePicker @bind-Value="context.Start"
                                    TValue="DateTime"
                                    Class="element-stretch"
                                    OnChange="@(x => UpdateCronExpression(this.selectedPeriod, x.Date))" />
                    </FormItem>
                }
                else
                {
                    <FormItem Label="Start & time of day" Required>
                        <DatePicker @bind-Value="context.Start"
                                    TValue="DateTime"
                                    ShowTime="@("HH:mm")"
                                    Class="element-stretch"
                                    OnChange="@(x => UpdateCronExpression(this.selectedPeriod, x.Date))" />
                    </FormItem>
                }

            </GridCol>

            <GridCol>
                <Divider Type="DirectionVHType.Vertical" />
            </GridCol>

            <GridCol Span="11">
                @if (exchange?.WithdrawalType == WithdrawalType.None)
                {
                    <Alert Type="@AlertType.Warning">
                        Withdrawal isn't currently supported for this exchange.
                        Feel free to contribute this feature on <a target="_blank" href="https://github.com/bezysoftware/autosats/issues">GitHub</a>.
                    </Alert>
                }
                else
                {
                    <FormItem Label="Withdrawal" Required LabelColSpan="10" WrapperColSpan="14">
                        <Select TItem="ExchangeWithdrawalType"
                                TItemValue="ExchangeWithdrawalType"
                                Disabled="isGeneratingAddress"
                                Loading="isGeneratingAddress && context.WithdrawalType == ExchangeWithdrawalType.Dynamic"
                                @bind-Value="context.WithdrawalType"
                                OnSelectedItemChanged="WithdrawalTypeChanged">
                            <SelectOptions>
                                @foreach (var w in withdrawalTypes ?? Enumerable.Empty<ExchangeWithdrawalType>())
                                {
                                    <SelectOption TItemValue="ExchangeWithdrawalType" TItem="ExchangeWithdrawalType" Value="w" Label="@(EnumHelper<ExchangeWithdrawalType>.GetDisplayName(w))" />
                                }
                            </SelectOptions>
                        </Select>
                    </FormItem>

                    @if (context.WithdrawalType == ExchangeWithdrawalType.Fixed)
                    {
                        <FormItem Label="Address" LabelColSpan="10" WrapperColSpan="14">
                            <AntDesign.Input @bind-Value="context.WithdrawalAddress">
                                <Suffix>
                                    <Tooltip Title="@("Generate address")">
                                        <Button Class="input-button" Type="@ButtonType.Text" Loading="isGeneratingAddress" OnClick="GenerateWithdrawalAddressAsync">
                                            <Icon Type="setting" Theme="outline" />
                                        </Button>
                                    </Tooltip>
                                </Suffix>
                            </AntDesign.Input>
                        </FormItem>
                    }

                    @if (context.WithdrawalType != ExchangeWithdrawalType.None)
                    {
                        <FormItem Label="Limit" Required LabelColSpan="10" WrapperColSpan="14">
                            <Tooltip Title="@("Once you accumulate at least this much BTC your entire balance will be withdrawn to your wallet (minus any fees)")">
                                <NumberInput @bind-Value="context.WithdrawalLimit"
                                             Class="element-stretch"
                                             Type="number"
                                             min="0"
                                             step="0.001">
                                    <AddOnAfter>
                                        BTC
                                    </AddOnAfter>
                                </NumberInput>
                            </Tooltip>
                        </FormItem>

                        @if (context.WithdrawalType == ExchangeWithdrawalType.Named)
                        {   
                            <div class="named-withdrawal">
                                <Alert Type="@AlertType.Info">
                                    @exchange?.Name supports withdrawal only to named pre-approved addresses.
                                    Make sure you set one up in <a href="@exchange?.ApiUrl" target="_blank">@exchange?.ApiName</a>
                                    and name it <strong>AutoSats</strong>. That's where your balance will be withdrawn to.
                                </Alert>
                                <Button Loading="isGeneratingAddress" OnClick="GenerateTempWithdrawalAddressAsync">
                                    Generate address
                                </Button>
                                @if (tempAddress != null)
                                {
                                    <AntDesign.Input @bind-Value="tempAddress"
                                                     ReadOnly="true" />
                                }
                            </div>
                        }
                    }
                }
            </GridCol>
        </Row>
        <Row Justify="center">
            <GridCol>
                <Checkbox @bind-Checked="context.RunToVerify" Class="verify-checkbox">
                    Run the schedule now to verify it
                </Checkbox>
            </GridCol>
        </Row>
        <Row>
            <GridCol Offset="9" Span="12">
                <FormItem>
                    <Button HtmlType="submit" Block Type="primary" Disabled="isGeneratingAddress">
                        @(context.RunToVerify ? "Verify and save" : "Save")
                    </Button>
                </FormItem>
            </GridCol>
        </Row>

        <AntDesign.Text Type="secondary" Class="run-definition-description">
            @if (context.RunToVerify)
            {
                <span>This will try to run your schedule definition right now and only save it if it succeeds.</span>
            }
        </AntDesign.Text>
    </Form>
</div>

@code {
    [Parameter] public EventCallback<ViewModels.ScheduleDetails> DetailsChanged { get; set; }
    [Parameter] public KeysWithBalances? KeysWithBalances { get; set; }

    private SchedulePeriod selectedPeriod { get; set; }
    private string? tempAddress { get; set; }
    private IEnumerable<ExchangeWithdrawalType>? withdrawalTypes { get; set; }

    private ViewModels.ScheduleDetails details = new ViewModels.ScheduleDetails();
    private bool isGeneratingAddress;
    private bool isSaving;
    private ExchangeOptions? exchange;

    protected override void OnInitialized()
    {
        this.exchange = KeysWithBalances?.Keys.Exchange ?? throw new InvalidOperationException();
        this.withdrawalTypes = exchange?.WithdrawalType == WithdrawalType.Address
            ? new[] { ExchangeWithdrawalType.None, ExchangeWithdrawalType.Fixed, ExchangeWithdrawalType.Dynamic }
            : new[] { ExchangeWithdrawalType.None, ExchangeWithdrawalType.Named };
        this.details.Symbol = KeysWithBalances.Balances.OrderByDescending(x => x.Amount).FirstOrDefault()?.Symbol;
    }

    private void SelectedPeriodChanged(SchedulePeriod period)
    {
        UpdateCronExpression(period, this.details.Start);
    }

    private void UpdateCronExpression(SchedulePeriod period, DateTime start)
    {
        switch (this.selectedPeriod)
        {
            case SchedulePeriod.Daily:
                this.details.Cron = $"0 {start.Minute} {start.Hour} * * ?";
                break;
            case SchedulePeriod.Weekly:
                this.details.Cron = $"0 {start.Minute} {start.Hour} ? * {start.ToString("ddd", System.Globalization.CultureInfo.InvariantCulture).ToUpper()}";
                break;
            case SchedulePeriod.Monthly:
                this.details.Cron = $"0 {start.Minute} {start.Hour} {start.Day} * ?";
                break;
        }
    }

    private async Task SaveScheduleAsync(EditContext context)
    {
        if (KeysWithBalances?.Keys.Exchange == null || this.details.Symbol == null)
        {
            return;
        }

        this.isSaving = true;
        var schedule = new NewExchangeSchedule(
            new SymbolBalance(this.details.Symbol, this.details.Spend),
            KeysWithBalances.Keys.Exchange.Name,
            KeysWithBalances.Keys.ToKeysArray(),
            this.details.Cron,
            this.details.Start,
            this.details.WithdrawalType,
            this.details.WithdrawalAddress,
            this.details.WithdrawalLimit);

        try
        {
            await scheduler.AddScheduleAsync(schedule, this.details.RunToVerify);
            await DetailsChanged.InvokeAsync(details);
        }
        catch (Exception ex)
        {
            await message.Error($"Couldn't add the schedule: {ex.Message}");
        }

        this.isSaving = false;
    }

    private async Task GenerateTempWithdrawalAddressAsync()
    {
        if (await GenerateWithdrawalAddressAsync())
        {
            this.tempAddress = this.details.WithdrawalAddress;
            this.details.WithdrawalAddress = null;
        }
    }

    private async Task<bool> GenerateWithdrawalAddressAsync()
    {
        this.isGeneratingAddress = true;

        try
        {
            this.details.WithdrawalAddress = await wallet.GenerateDepositAddressAsync();
            return true;
        }
        catch (Exception ex)
        {
            await message.Error($"Couldn't generate address from your wallet: {ex.Message}");
            return false;
        }
        finally
        {
            this.isGeneratingAddress = false;
        }
    }

    private async void WithdrawalTypeChanged(ExchangeWithdrawalType type)
    {
        if (type == ExchangeWithdrawalType.Dynamic && !(await GenerateWithdrawalAddressAsync()))
        {
            this.details.WithdrawalType = ExchangeWithdrawalType.None;
        }

        StateHasChanged();
    }
}